
---

## 1. **ما هو ADT؟ (Abstract Data Type)**

### إيه هو الـ **ADT**؟
**ADT** هو اختصار لـ **نوع البيانات المجرد** (Abstract Data Type)، وده يعني إننا بنتعامل مع نوع معين من البيانات دون ما نهتم بكيفية تخزينها أو تنفيذ العمليات عليها. كل اللي بنهتم بيه هو **العمليات** اللي نقدر نعملها على هذا النوع من البيانات.

### إزاي يعني؟ يعني إيه "مجرد"؟
الـ **ADT** هو مجرد **وصف** لنوع البيانات، حيث يحدد لك العمليات الممكن تنفيذها عليه، لكن دون الدخول في التفاصيل الخاصة بكيفية تنفيذ هذه العمليات داخل الذاكرة. الفكرة في **الـ ADT** هي أن تهتم بما يمكن أن تفعله مع البيانات فقط، دون التفكير في الطريقة التي يتم بها تخزينها أو معالجتها.

### مثال توضيحي:
خد مثلاً الـ **Stack**  كمثال للـ **ADT**. 
- الـ **ADT** بتاع الـ **Stack** يقول لك إنه يوجد عمليتين رئيسيتين: 
  - **Push**: إضافة عنصر إلى المكدس.
  - **Pop**: إزالة العنصر الذي تم إدخاله مؤخراً.
  - **Peek**: رؤية العنصر الذي على قمة المكدس دون إزالته.

لكن في **الـ ADT**، لا يهمك كيف يتم تخزين البيانات داخل الـ Stack، هل باستخدام مصفوفة أم باستخدام قائمة مترابطة، لأن الـ ADT فقط يحدد العمليات التي يمكن إجراؤها على المكدس، ولا يهتم بالتفاصيل التنفيذية.

---

## 2. **نظرة سريعة على أنواع الـ Data Structures **:

### **Arrays (المصفوفات)**:
المصفوفة هي **مجموعة من العناصر** المتشابهة (مثل الأرقام أو النصوص) التي يتم تخزينها في أماكن متجاورة في الذاكرة. المصفوفة تحتوي على **فهرس** (Index) يساعدنا للوصول إلى أي عنصر في المصفوفة بسرعة.

#### مثال على المصفوفات:
في **بايثون**، يمكن استخدام **القائمة**  كمصفوفة:

```python
arr = [10, 20, 30, 40, 50]
print(arr[2])  # هيتطبع 30 لأن العنصر في الفهرس رقم 2 هو 30
```

في المثال السابق، المصفوفة `arr` تحتوي على 5 عناصر، وعند استخدام الفهرس `[2]` نتمكن من الوصول إلى العنصر الذي يحمل القيمة `30`.

---

### **Linked List (القائمة المترابطة)**:
الـ **Linked List** هو هيكل بيانات يتكون من **عقد** (Nodes)، حيث يحتوي كل عقدة على:
- **بيانات** (Data).
- **مؤشر** (Pointer) يشير إلى العقدة التالية في السلسلة.

الـ **Linked List** يختلف عن المصفوفة في أن العناصر لا تكون مخزنة في أماكن متجاورة في الذاكرة. بدلاً من ذلك، كل عنصر يحتوي على مؤشر يشير إلى العنصر الذي يليه.

#### مثال على الـ Linked List:

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None  # مؤشر للعقدة التالية

class LinkedList:
    def __init__(self):
        self.head = None  # رأس القائمة

    def append(self, data):
        new_node = Node(data)
        new_node.next = self.head  # ربط العنصر الجديد بالقائمة
        self.head = new_node  # تحديث رأس القائمة

# إنشاء القائمة
ll = LinkedList()
ll.append(10)
ll.append(20)
```

في المثال السابق، أنشأنا **قائمة مترابطة** تحتوي على عقد تحتوي على بيانات وأيضًا مؤشرات تشير إلى العقد التالية.

---

### **Stack (المكدس)**:
الـ **Stack** هو هيكل بيانات يعتمد على مبدأ **LIFO** (Last In, First Out)، أي أن العنصر الأخير الذي تم إدخاله هو أول عنصر سيتم إزالته.

#### مثال على الـ Stack:

```python
stack = []
stack.append(10)  # إضافة عنصر للمكدس (Push)
stack.append(20)
stack.append(30)

print(stack.pop())  # إزالة العنصر الأخير (30) من المكدس (Pop)
```

في المثال السابق، استخدمنا **قائمة بايثون** لتنفيذ **Push** و **Pop** على الـ Stack، حيث يتم إضافة العناصر في النهاية وإزالتها من النهاية أيضًا.

---

### **Queue (الطابور)**:
الـ **Queue** هو هيكل بيانات يعتمد على مبدأ **FIFO** (First In, First Out)، أي أن أول عنصر يدخل هو أول عنصر يخرج.

#### مثال على الـ Queue:

```python
from collections import deque
queue = deque()
queue.append(10)  # إضافة عنصر للطابور (Enqueue)
queue.append(20)
queue.append(30)

print(queue.popleft())  # إزالة العنصر الأول من الطابور (Dequeue)
```

في المثال السابق، استخدمنا **deque** من مكتبة **collections** في بايثون لتنفيذ **Enqueue** و **Dequeue** على الـ Queue. يتم إضافة العناصر في النهاية وإزالتها من البداية.

---

### 3. **أنواع الـ Data Structures بناءً على وجودها**:

#### **1. Physical Data Structures (الهياكل البيانية المادية)**:
هذه الهياكل هي التي تخزن البيانات في الذاكرة بشكل فعلي. البيانات يتم تخصيص أماكن لها في الذاكرة بحيث تكون متجاورة أو مترابطة حسب نوع الهيكل.

- **Arrays (المصفوفات)**: البيانات مخزنة في أماكن متجاورة في الذاكرة.
- **Linked List (القائمة المترابطة)**: البيانات تكون متفرقة في الذاكرة، وكل عنصر يشير إلى العنصر التالي عبر مؤشر.

#### **2. Logical Data Structures (الهياكل البيانية المنطقية)**:
هذه الهياكل لا تهم طريقة تخزين البيانات في الذاكرة بشكل متسلسل، وإنما تركز على كيفية تمثيل العلاقة بين العناصر. تستخدم عادة لتمثيل علاقات أكثر تعقيدًا بين العناصر.

- **Stack (المكدس)**: هيكل بيانات يعتمد على مبدأ **LIFO** (Last In, First Out) حيث يتم إضافة العناصر وإزالتها من نهاية الهيكل.
- **Queue (الطابور)**: هيكل بيانات يعتمد على مبدأ **FIFO** (First In, First Out) حيث يتم إضافة العناصر في النهاية وإزالتها من البداية.

---

### 4. **أنواع الـ Data Structures بناءً على تخصيص الذاكرة**:

#### **1. Static Memory Allocation (تخصيص الذاكرة الثابتة)**:
الذاكرة التي يتم تخصيصها في وقت الترجمة ولا يمكن تعديلها أثناء تشغيل البرنامج. مثال على ذلك: **المصفوفات**.

#### **2. Dynamic Memory Allocation (تخصيص الذاكرة الديناميكية)**:
الذاكرة التي يتم تخصيصها أثناء تشغيل البرنامج ويمكن تعديلها وتخصيص المزيد منها حسب الحاجة. مثال على ذلك: **القوائم المترابطة** (Linked List).

---

### 5. **أنواع الـ Data Structures بناءً على التمثيل**:

#### **1. Linear Data Structures (الهياكل البيانية الخطية)**:
الهياكل التي تكون البيانات فيها مرتبة بشكل متسلسل. مثال: **المصفوفات** و **القوائم المترابطة** و **المكدس** و **الطابور**.

#### **2. Non-Linear Data Structures (الهياكل البيانية غير الخطية)**:
الهياكل التي لا تكون فيها البيانات مرتبة بشكل خطي، مثل:  (Trees) و  (Graphs).

---

**ملخص الأنواع التي تندرج تحت كل نوع:**

1. **Physical Data Structures**:
   - Arrays 
   - Linked List 

2. **Logical Data Structures**:
   - Stack 
   - Queue 
3. **Static vs Dynamic Memory Allocation**:
   - Static: Arrays
   - Dynamic: Linked List, Trees

4. **Linear vs Non-Linear Data Structures**:
   - Linear: Arrays, Linked List, Stack, Queue
   - Non-Linear: Trees, Graphs

---

## **ملخص سريع**:

- **ADT** هو نوع بيانات مجرّد يحدد العمليات الممكن تنفيذها عليه دون الاهتمام بكيفية تنفيذها.
- **Data Structures** مثل المصفوفات، القوائم المترابطة، المكدس، الطابور والأشجار هي الهياكل التي تنظم البيانات.
- **الهياكل البيانية** قد تكون **مادية** أو **منطقية**، **ثابتة** أو **ديناميكية**، **خطية** أو **غير خطية**.

---
